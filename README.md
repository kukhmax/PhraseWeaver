### Общий План разработки (Roadmap)

#  версия python 3.11.9 !!!!

Прежде чем мы напишем первую строчку кода, я хочу обозначить общую последовательность наших действий, чтобы у вас было полное понимание процесса:

Шаг 0: Подготовка рабочего окружения и структуры проекта. Создадим фундамент: папки, базовые файлы, настроим виртуальное окружение. (Наш текущий шаг)

Шаг 1: Создание слоя для работы с базой данных. Напишем код, который будет управлять таблицами SQLite, чтобы остальное приложение могло легко сохранять и получать данные.

    Резюме шага 1:

    Мы создали изолированный модуль для работы с базой данных (core/database.py).
    При первом запуске он автоматически создает всю необходимую структуру таблиц согласно ТЗ.
    Мы реализовали базовые функции для создания и получения списка колод.
    Приложение теперь корректно управляет жизненным циклом соединения с БД (открывает при старте, закрывает при выходе).
    Мы использовали лучшие практики: логирование, обработку ошибок, автоматическое управление транзакциями и row_factory для удобного получения данных.

Шаг 2: Разработка базового UI на Kivy/KivyMD. Создадим главный экран "Колоды" и настроим навигацию между экранами. Пока без логики.

    Резюме шага 2:
    
    Мы создали архитектуру для многоэкранного приложения с помощью ScreenManager.
    Мы вынесли дизайн и логику первого экрана (DeckListScreen) в отдельный файл, следуя лучшим практикам.
    Мы научились отделять структуру интерфейса (KV-язык) от логики на Python.
    Наше приложение теперь не просто запускается, а показывает реальные данные из базы данных, динамически строя по ним список.
    Мы заложили основу для навигации — при нажатии на колоду мы уже можем отследить это событие.


Шаг 3: Разработка модуля "Обогащения". Напишем ядро нашего приложения — код, который будет ходить в интернет за переводами, примерами и аудио. Мы сделаем его полностью независимым от интерфейса.

    Резюме шага 3:

    Перевод успешно получен.
    Аудио для фразы и перевода сгенерировано.
    Приложение столкнулось с Ratelimit от DuckDuckGo. Это нормальное поведение, и наш код правильно его обработал: он не упал, а вежливо сообщил об ошибке и вернул пустой список примеров. Это как раз та надежность, к которой мы стремились. В реальном использовании такие лимиты срабатывают редко.
    Программа завершилась корректно и собрала все данные, которые смогла получить.

Шаг 4: Интеграция. Экран создания карточки. Свяжем UI и модуль "Обогащения". Создадим экран, где пользователь сможет вводить фразу и запускать процесс обогащения контента.

    Резюме шага 4:

    1. Создали новый Экран "Создания Карточки":
        - Разработали UI (CreationScreen) с полями для ввода полного предложения и ключевой фразы.
        - Разместили на нем кнопки для запуска процесса ("Обогатить") и сохранения результата ("Сохранить в колоду").
    2. Реализовали главную "фишку" приложения — асинхронное обогащение:
        - Написали логику, которая по нажатию кнопки "Обогатить ✨" запускает наш enrichment.py в отдельном фоновом потоке.
        - Это гарантирует, что интерфейс приложения никогда не "зависает", даже если поиск перевода или примеров занимает много времени. Пользователь всегда может взаимодействовать с приложением.
    3. Создали интуитивно понятный пользовательский опыт (UX) для долгой операции:
        - При запуске обогащения кнопка становится неактивной, и появляется индикатор загрузки (спиннер). Пользователь визульно понимает, что идет работа.
        - После завершения процесса спиннер исчезает, и на экране появляются результаты (перевод и примеры) в виде интерактивных кнопок.
        - Кнопка "Сохранить" активируется только после успешного получения данных, что логично и предотвращает сохранение пустых карточек.
    4. Наладили навигацию:
        - Теперь с главного экрана (DeckListScreen) можно перейти на экран создания, нажав плавающую кнопку "+".
        - С экрана создания можно вернуться назад, используя системную кнопку "назад" или стрелку в левом верхнем углу.
    5. Провели масштабную отладку и адаптацию:
        - Мы столкнулись с реальными проблемами разработки: несовместимость версий библиотек (translators, httpx), различия в версиях Python.
        - Мы успешно обновили фреймворк KivyMD до последней версии и адаптировали весь наш UI-код к его новому API, исправив множество ошибок импорта и использования виджетов.
        - Мы отладили сложную логику управления состоянием UI (вечные спиннеры), сделав ее надежной.

Шаг 5: Реализация алгоритма SRS и экрана тренировки. Создадим логику интервальных повторений и интерфейс для прохождения карточек.

    Резюме шага 5:

    1. "Оживили" кнопку "Сохранить":
        - Расширили наш DatabaseManager новыми методами, которые теперь умеют сохранять не только колоды, но и сложные "Концепты" (фраза, перевод, примеры, аудио) и связанные с ними тренировочные карточки.
        - Реализовали проверку на дубликаты: приложение не позволит сохранить одну и ту же ключевую фразу дважды.
    2. Автоматизировали создание учебного материала:
        - Написали логику, которая из одного созданного пользователем "Концепта" автоматически генерирует до трех разных тренировочных карточек (прямая, обратная, заполнение пропуска). Это ядро нашего УТП — максимальная автоматизация для пользователя.
    3.Создали мозг системы — алгоритм интервальных повторений (SRS):
        - Разработали отдельный, чистый модуль core/srs.py.
        - В нем реализовали функцию calculate_next_due_date, которая на основе оценки пользователя ("Снова", "Хорошо", "Легко") вычисляет, когда нужно показать карточку в следующий раз. Это обеспечивает эффективное долгосрочное запоминание.
    4. Построили "Тренажерный зал" — Экран Тренировки:
        - Создали TrainingScreen — главный экран, где происходит обучение.
        - Он запрашивает из БД только те карточки, у которых подошло время повторения (due_date <= сегодня).
        - Реализовали классический интерфейс "вопрос-ответ": показ "лица" карточки, затем по кнопке — "оборота".
        - Интегрировали кнопки оценки с нашим SRS-алгоритмом. После каждой оценки карточка обновляется в БД с новой датой повторения.
    5. Сделали главный экран информативным:
        - Экран со списком колод (DeckListScreen) теперь не просто показывает названия, а выводит счетчик карточек, готовых к повторению в каждой колоде.
        - Нажатие на колоду теперь запускает сеанс тренировки, если в ней есть что повторять.

Шаг 6: Финальная полировка и сборка. Добавим обработку ошибок, "умную" вставку из буфера обмена и подготовим все для сборки в .apk файл.

О

### **Roadmap разработки PhraseWeaver v2.0**

Наша цель — превратить рабочий прототип в более умный, красивый и функциональный инструмент.

**Общая стратегия:** Мы будем двигаться от "невидимых" бэкенд-изменений к видимым для пользователя UI/UX улучшениям.

---

#### **Шаг 6: Мультиязычность и Умные Колоды**

**Цель:** Научить приложение работать с несколькими языками, привязав язык к колоде.

1.  **Модификация Базы Данных:**
    *   Добавим в таблицу `decks` новое поле: `lang_code TEXT NOT NULL DEFAULT 'en'`.
    *   Обновим метод `DatabaseManager.create_deck`, чтобы он принимал и сохранял код языка.
2.  **Обновление UI Создания Колоды:**
    *   Сейчас у нас нет отдельного UI для создания колоды (мы делали это в коде). Пора его создать!
    *   На экране `DeckListScreen` изменим кнопку `+`. Теперь она будет открывать простое диалоговое окно, где пользователь вводит `имя новой колоды` и **выбирает язык** из выпадающего списка (`Английский`, `Испанский`, `Португальский`).
3.  **Интеграция в Процесс Обогащения:**
    *   Когда пользователь добавляет карточку в "Испанскую" колоду, `CreationScreen` будет передавать `lang_code='es'` в наш модуль `enrichment.py`.
    *   `enrichment.py` будет использовать этот код для:
        *   **Перевода:** `googletrans` будет переводить с `src='es'` на `dest='ru'`.
        *   **Озвучки:** `gTTS` будет генерировать аудио с `lang='es'`.
4.  **Реализация "Умного бонуса":**
    *   В `CreationScreen`, после ввода фразы, незаметно вызовем `googletrans.detect()`. Если определенный язык не совпадает с языком колоды, покажем маленькую иконку-предупреждение или ненавязчивое уведомление (`Snackbar`) с текстом: "Похоже, это португальский. Все равно добавить в испанскую колоду?".

---

#### **Шаг 7: Расширенное Обогащение — Картинки и Контекст**


### **Шаг 7 (v3.0): Интерактивное Обогащение с Визуальным Подтверждением**

**Общая Цель:** Создать процесс, в котором пользователь вводит ключевое слово, получает на выбор список готовых фраз-примеров с переводом **И** картинку-ассоциацию, утверждает всё это, и одним нажатием сохраняет в колоду набор визуально подкрепленных карточек.

---

#### **Шаг 7.1: Backend — Двойной Удар (Фразы + Картинка)**

**Цель:** Научить систему одновременно искать и текстовые примеры, и визуальный образ.

1.  **Парсер Reverso Context (Без изменений):**
    *   Задача: Создать `core/reverso_parser.py` с функцией `find_examples_on_reverso`.
    *   Результат: Возвращает список словарей `[{'original': ..., 'translation': ...}]`. Эту часть плана мы сохраняем.

2.  **Поиск Картинки (Новая задача):**
    *   Задача: Добавить в `core/enrichment.py` новую асинхронную функцию `find_image_for_keyword(keyword)`.
    *   **Действия:**
        *   Она будет использовать библиотеку `duckduckgo-search`, которая у нас уже есть в `requirements.txt`.
        *   Она выполнит асинхронный поиск по картинкам: `AsyncDDGS().images(keyword)`.
        *   Она скачает **одну**, самую первую и самую релевантную картинку.
        *   Она сохранит ее в папку `assets/images/` (нужно будет убедиться, что папка создается при старте приложения).
        *   **Результат:** Функция вернет локальный путь к скачанному файлу, например `'assets/images/my_keyword_image.jpg'`.

---

#### **Шаг 7.2: Frontend — Экран Курирования "Все-в-одном"**

**Цель:** Полностью перепроектировать новый экран `CurationScreen`, чтобы на нем можно было утверждать и фразы, и картинку.

1.  **Создание `CurationScreen.py` и разметка в `main.py`:**
    *   В `KV` мы опишем новую структуру экрана.
    *   **Верхняя часть:** Здесь будет `MDCard` для предпросмотра изображения. Внутри него — виджет `FitImage` или `Image`, который будет отображать найденную картинку. Рядом с ним можно добавить маленькие кнопки-иконки "Найти другую" и "Без картинки".
    *   **Нижняя часть:** Под карточкой с картинкой будет `ScrollView` со списком `MDList` наших пар фраз (оригинал + перевод). Как и планировалось, у каждой пары будет кнопка "Удалить".
    *   **Финальная кнопка:** В самом низу — "Добавить выбранное в колоду".

---

#### **Шаг 7.3: Logic — Перестройка Пользовательского Пути**

**Цель:** Оркестрировать новый, более сложный процесс получения, подтверждения и сохранения данных.

1.  **Изменяем `creation_screen.py`:**
    *   Метод `enrich_button_pressed` теперь — дирижер.
    *   Он **одновременно** запускает `find_examples_on_reverso` и `find_image_for_keyword` (с помощью `asyncio.gather` для параллельного выполнения).
    *   Он получает от них два результата: `список_фраз` и `путь_к_картинке`.
    *   Он передает **оба** этих результата на `CurationScreen` и переключает на него вид.

2.  **Пишем логику `CurationScreen.py`:**
    *   `on_enter` принимает `список_фраз` и `путь_к_картинке`. Он заполняет и `MDList` списком фраз, и `Image` в верхней части экрана.
    *   Логика кнопки "Удалить фразу" остается прежней.
    *   **Ключевой метод "Добавить выбранное":**
        1.  Он считывает финальный `путь_к_картинке` из виджета `Image`.
        2.  Он проходит по всем **оставшимся** элементам списка фраз.
        3.  Для **каждого** элемента он:
            *   Берет `original` и `translation`.
            *   Формирует `enriched_data` для этого конкретного концепта.
            *   **ВАЖНО:** Добавляет в этот словарь `путь_к_картинке`: `enriched_data['image_path'] = путь_к_картинке`.
            *   Вызывает `db_manager.create_concept_and_cards` с этими данными.
        4.  После цикла показывает `Snackbar` и возвращается на главный экран.

---

#### **Шаг 7.4: Database — Подготовка к хранению картинок**

**Цель:** Расширить нашу базу данных, чтобы она могла хранить информацию об изображениях.

1.  **Изменяем `core/database.py`:**
    *   **SQL:** В методе, который создает таблицу `concepts`, мы добавляем новое поле: `image_path TEXT DEFAULT NULL`.
    *   **Логика:** В методе `create_concept_and_cards` (или его аналоге) мы модифицируем `INSERT`-запрос. Теперь он должен проверять, есть ли в словаре `enriched_data` ключ `image_path`, и если есть — вставлять это значение в новую колонку.

---

#### **Шаг 8: Редизайн и Улучшение Тренировки**

**Цель:** Сделать приложение красивее и внедрить новый, более эффективный режим тренировки.

1.  **Новый тип карточки "Понимание на слух/в контексте":**
    *   В `DatabaseManager._generate_cards_for_concept` добавим создание нового типа карточки (`comprehension`). `front` будет содержать один из примеров, а `back` — перевод ключевой фразы.
2.  **Редизайн Экрана Тренировки:**
    *   Полностью переделаем `TrainingScreen`.
    *   При показе карточки типа `comprehension`:
        *   Вверху показываем **картинку**, связанную с концептом.
        *   Под ней — **кнопка "Play"** для прослушивания аудио примера.
        *   Ниже — сам **текст примера** с пропуском (`... a blessing in ______`).
    *   По кнопке "Показать ответ" открывается вся фраза целиком и ее перевод.
3.  **Внедрение "Вайба" Duolingo:**
    *   **Цветовая схема:** Изменим `primary_palette` в `main.py` на более яркую (например, `Green` или `Teal`).
    *   **Стиль карточек:** В KV-разметке `TrainingScreen` стилизуем `MDCard`, добавив им `radius` (закругленные углы) и `line_color`.
    *   **Звуковые эффекты:** Добавим в `assets/audio` два коротких звука: `correct.mp3` и `wrong.mp3`. В `TrainingScreen`, в методе `evaluate_answer`, будем проигрывать соответствующий звук при оценке "хорошо/легко" или "снова". Kivy имеет простой API для проигрывания звуков.

---

**Итог плана:**

*   **Шаг 6: Бэкенд для языков.** Основа для дальнейшего развития.
*   **Шаг 7: Улучшение контента.** Делаем каждую карточку в 10 раз ценнее.
*   **Шаг 8: UI/UX.** Делаем приложение приятным и эффективным в использовании.

Три Режима Тренировки в Одной Сессии**

Вместо того чтобы делать только два типа "вопрос-ответ", мы можем легко реализовать три, которые будут случайно перемешиваться и тренировать разные навыки:

1.  **"Классическая Карточка" (Распознавание):**
    *   **Показываем:** Фразу на иностранном + картинку + кнопку "Play".
    *   **Действие:** Пользователь нажимает "Показать перевод".
    *   **Тренирует:** Пассивное узнавание. Самый легкий режим, идеален для знакомства с фразой.

2.  **"Перевод-Спринт" (Активное Воспроизведение):**
    *   **Показываем:** Перевод на русском + картинку.
    *   **Действие:** Пользователь должен **напечатать** фразу на иностранном языке. Мы сравниваем и показываем галочку/крестик.
    *   **Тренирует:** Активную память. Самый сложный и самый эффективный режим для запоминания.

3.  **"Понимание в Контексте" (Новый режим!):**
    *   **Показываем:** Одну из фраз-примеров, которые нашел AI, но с **пропуском** на месте ключевого слова (например, `I am going ______ after work.`) + картинку + кнопку "Play".
    *   **Действие:** Пользователь должен **напечатать** пропущенное ключевое слово.
    *   **Тренирует:** Понимание контекста и правильное использование слова. Это — высший пилотаж.

Эта система превращает каждую тренировку в непредсказуемый и увлекательный процесс, который не дает мозгу заскучать.

### **План Дальнейших Действий: Перестройка Тренажерного Зала**

Это большой, но очень захватывающий шаг. Мы полностью переделаем `TrainingScreen`. Давай разобьем его на логичные этапы.

---

#### **Шаг 10: Бэкенд и Данные — Готовим "Патроны" для Тренировки**

**Цель:** Научить `DatabaseManager` создавать новые, более "умные" типы карточек, которые нужны для наших новых режимов.

1.  **Модификация `_generate_cards_for_concept`:**
    *   Откроем `core/database.py`.
    *   Мы сильно изменим метод `_generate_cards_for_concept`. Теперь для **каждого** "концепта" (то есть для каждой фразы-примера) он будет создавать не две, а **три** карточки в базе данных:
        *   `type='direct'`: `front` = иностранная фраза, `back` = перевод.
        *   `type='reverse_recall'`: `front` = перевод, `back` = иностранная фраза.
        *   `type='context_cloze'`: `front` = `{ "context": "I am going ... after work.", "audio": "path/to/audio.mp3" }`, `back` = `home`. (Мы будем хранить данные в формате JSON прямо в текстовых полях).

---

#### **Ша- 11: Frontend — Строим новый, интерактивный интерфейс `TrainingScreen`**

**Цель:** Полностью переписать разметку `KV` для экрана тренировки, чтобы на нем были все нужные нам элементы.

1.  **Редизайн в `main.py`:**
    *   Откроем `main.py` и найдем блок `<TrainingScreen>`.
    *   Мы добавим в него:
        *   `MDTopAppBar` с `MDProgressBar` внутри.
        *   Главную `MDCard` для "вопроса". В ней будет `FitImage` для картинки, `MDLabel` для текста/контекста и `MDIconButton` для проигрывания аудио.
        *   Область "ответа", которая будет меняться. В ней будут:
            *   `MDLabel` (для показа ответа в "классическом" режиме).
            *   `MDTextField` (для ввода ответа в режимах "Спринт" и "Контекст").
            *   `MDIconButton` (для иконки галочки/крестика).
        *   Нижняя панель с кнопками оценки SRS ("Снова", "Хорошо", "Легко"), которые изначально будут скрыты.

---

#### **Шаг 12: Logic — Пишем "Мозг" Тренажера**

**Цель:** Реализовать всю логику в `screens/training_screen.py`.

1.  **Полная переработка `TrainingScreen`:**
    *   **`on_enter`:** Загружаем **все** доступные для повторения карточки из колоды и **перемешиваем** их (`random.shuffle`).
    *   **`show_next_card()`:** Это будет главный метод-дирижер.
        *   Берет следующую карточку из перемешанного списка.
        *   Смотрит на ее `card_type`.
        *   В зависимости от типа, вызывает соответствующий метод настройки: `_setup_classic_card()`, `_setup_recall_card()` или `_setup_context_card()`.
    *   **Методы настройки (`_setup_...`)**: Каждый из этих методов будет настраивать UI под конкретную задачу (показывать/прятать `MDTextField`, менять текст на кнопках и т.д.).
    *   **`check_answer()` (Новый метод):** Будет вызываться, когда пользователь ввел текст в `MDTextField`. Он сравнит ввод с правильным ответом в `card['back']`, покажет галочку или крестик, а затем покажет кнопки оценки SRS.
    *   **`evaluate_answer()`:** Этот метод почти не изменится. Он, как и раньше, будет отвечать за расчет SRS и вызов `show_next_card()` для перехода к следующему испытанию.



