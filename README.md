### Общий План разработки (Roadmap)

#  версия python 3.11.9 !!!!

Прежде чем мы напишем первую строчку кода, я хочу обозначить общую последовательность наших действий, чтобы у вас было полное понимание процесса:

Шаг 0: Подготовка рабочего окружения и структуры проекта. Создадим фундамент: папки, базовые файлы, настроим виртуальное окружение. (Наш текущий шаг)

Шаг 1: Создание слоя для работы с базой данных. Напишем код, который будет управлять таблицами SQLite, чтобы остальное приложение могло легко сохранять и получать данные.

    Резюме шага 1:

    Мы создали изолированный модуль для работы с базой данных (core/database.py).
    При первом запуске он автоматически создает всю необходимую структуру таблиц согласно ТЗ.
    Мы реализовали базовые функции для создания и получения списка колод.
    Приложение теперь корректно управляет жизненным циклом соединения с БД (открывает при старте, закрывает при выходе).
    Мы использовали лучшие практики: логирование, обработку ошибок, автоматическое управление транзакциями и row_factory для удобного получения данных.

Шаг 2: Разработка базового UI на Kivy/KivyMD. Создадим главный экран "Колоды" и настроим навигацию между экранами. Пока без логики.

    Резюме шага 2:
    
    Мы создали архитектуру для многоэкранного приложения с помощью ScreenManager.
    Мы вынесли дизайн и логику первого экрана (DeckListScreen) в отдельный файл, следуя лучшим практикам.
    Мы научились отделять структуру интерфейса (KV-язык) от логики на Python.
    Наше приложение теперь не просто запускается, а показывает реальные данные из базы данных, динамически строя по ним список.
    Мы заложили основу для навигации — при нажатии на колоду мы уже можем отследить это событие.


Шаг 3: Разработка модуля "Обогащения". Напишем ядро нашего приложения — код, который будет ходить в интернет за переводами, примерами и аудио. Мы сделаем его полностью независимым от интерфейса.

    Резюме шага 3:

    Перевод успешно получен.
    Аудио для фразы и перевода сгенерировано.
    Приложение столкнулось с Ratelimit от DuckDuckGo. Это нормальное поведение, и наш код правильно его обработал: он не упал, а вежливо сообщил об ошибке и вернул пустой список примеров. Это как раз та надежность, к которой мы стремились. В реальном использовании такие лимиты срабатывают редко.
    Программа завершилась корректно и собрала все данные, которые смогла получить.

Шаг 4: Интеграция. Экран создания карточки. Свяжем UI и модуль "Обогащения". Создадим экран, где пользователь сможет вводить фразу и запускать процесс обогащения контента.

    Резюме шага 4:

    1. Создали новый Экран "Создания Карточки":
        - Разработали UI (CreationScreen) с полями для ввода полного предложения и ключевой фразы.
        - Разместили на нем кнопки для запуска процесса ("Обогатить") и сохранения результата ("Сохранить в колоду").
    2. Реализовали главную "фишку" приложения — асинхронное обогащение:
        - Написали логику, которая по нажатию кнопки "Обогатить ✨" запускает наш enrichment.py в отдельном фоновом потоке.
        - Это гарантирует, что интерфейс приложения никогда не "зависает", даже если поиск перевода или примеров занимает много времени. Пользователь всегда может взаимодействовать с приложением.
    3. Создали интуитивно понятный пользовательский опыт (UX) для долгой операции:
        - При запуске обогащения кнопка становится неактивной, и появляется индикатор загрузки (спиннер). Пользователь визульно понимает, что идет работа.
        - После завершения процесса спиннер исчезает, и на экране появляются результаты (перевод и примеры) в виде интерактивных кнопок.
        - Кнопка "Сохранить" активируется только после успешного получения данных, что логично и предотвращает сохранение пустых карточек.
    4. Наладили навигацию:
        - Теперь с главного экрана (DeckListScreen) можно перейти на экран создания, нажав плавающую кнопку "+".
        - С экрана создания можно вернуться назад, используя системную кнопку "назад" или стрелку в левом верхнем углу.
    5. Провели масштабную отладку и адаптацию:
        - Мы столкнулись с реальными проблемами разработки: несовместимость версий библиотек (translators, httpx), различия в версиях Python.
        - Мы успешно обновили фреймворк KivyMD до последней версии и адаптировали весь наш UI-код к его новому API, исправив множество ошибок импорта и использования виджетов.
        - Мы отладили сложную логику управления состоянием UI (вечные спиннеры), сделав ее надежной.

Шаг 5: Реализация алгоритма SRS и экрана тренировки. Создадим логику интервальных повторений и интерфейс для прохождения карточек.

    Резюме шага 5:

    1. "Оживили" кнопку "Сохранить":
        - Расширили наш DatabaseManager новыми методами, которые теперь умеют сохранять не только колоды, но и сложные "Концепты" (фраза, перевод, примеры, аудио) и связанные с ними тренировочные карточки.
        - Реализовали проверку на дубликаты: приложение не позволит сохранить одну и ту же ключевую фразу дважды.
    2. Автоматизировали создание учебного материала:
        - Написали логику, которая из одного созданного пользователем "Концепта" автоматически генерирует до трех разных тренировочных карточек (прямая, обратная, заполнение пропуска). Это ядро нашего УТП — максимальная автоматизация для пользователя.
    3.Создали мозг системы — алгоритм интервальных повторений (SRS):
        - Разработали отдельный, чистый модуль core/srs.py.
        - В нем реализовали функцию calculate_next_due_date, которая на основе оценки пользователя ("Снова", "Хорошо", "Легко") вычисляет, когда нужно показать карточку в следующий раз. Это обеспечивает эффективное долгосрочное запоминание.
    4. Построили "Тренажерный зал" — Экран Тренировки:
        - Создали TrainingScreen — главный экран, где происходит обучение.
        - Он запрашивает из БД только те карточки, у которых подошло время повторения (due_date <= сегодня).
        - Реализовали классический интерфейс "вопрос-ответ": показ "лица" карточки, затем по кнопке — "оборота".
        - Интегрировали кнопки оценки с нашим SRS-алгоритмом. После каждой оценки карточка обновляется в БД с новой датой повторения.
    5. Сделали главный экран информативным:
        - Экран со списком колод (DeckListScreen) теперь не просто показывает названия, а выводит счетчик карточек, готовых к повторению в каждой колоде.
        - Нажатие на колоду теперь запускает сеанс тренировки, если в ней есть что повторять.

Шаг 6: Финальная полировка и сборка. Добавим обработку ошибок, "умную" вставку из буфера обмена и подготовим все для сборки в .apk файл.

О

### **Roadmap разработки PhraseWeaver v2.0**

Наша цель — превратить рабочий прототип в более умный, красивый и функциональный инструмент.

**Общая стратегия:** Мы будем двигаться от "невидимых" бэкенд-изменений к видимым для пользователя UI/UX улучшениям.

---

#### **Шаг 6: Мультиязычность и Умные Колоды**

**Цель:** Научить приложение работать с несколькими языками, привязав язык к колоде.

1.  **Модификация Базы Данных:**
    *   Добавим в таблицу `decks` новое поле: `lang_code TEXT NOT NULL DEFAULT 'en'`.
    *   Обновим метод `DatabaseManager.create_deck`, чтобы он принимал и сохранял код языка.
2.  **Обновление UI Создания Колоды:**
    *   Сейчас у нас нет отдельного UI для создания колоды (мы делали это в коде). Пора его создать!
    *   На экране `DeckListScreen` изменим кнопку `+`. Теперь она будет открывать простое диалоговое окно, где пользователь вводит `имя новой колоды` и **выбирает язык** из выпадающего списка (`Английский`, `Испанский`, `Португальский`).
3.  **Интеграция в Процесс Обогащения:**
    *   Когда пользователь добавляет карточку в "Испанскую" колоду, `CreationScreen` будет передавать `lang_code='es'` в наш модуль `enrichment.py`.
    *   `enrichment.py` будет использовать этот код для:
        *   **Перевода:** `googletrans` будет переводить с `src='es'` на `dest='ru'`.
        *   **Озвучки:** `gTTS` будет генерировать аудио с `lang='es'`.
4.  **Реализация "Умного бонуса":**
    *   В `CreationScreen`, после ввода фразы, незаметно вызовем `googletrans.detect()`. Если определенный язык не совпадает с языком колоды, покажем маленькую иконку-предупреждение или ненавязчивое уведомление (`Snackbar`) с текстом: "Похоже, это португальский. Все равно добавить в испанскую колоду?".

---

#### **Шаг 7: Расширенное Обогащение — Картинки и Контекст**

**Цель:** Добавить визуальные ассоциации (картинки) и улучшить поиск примеров.

1.  **Модификация Базы Данных:**
    *   Добавим в таблицу `concepts` новое поле: `image_path TEXT`.
2.  **Обновление `enrichment.py`:**
    *   Добавим новую асинхронную функцию `find_image_for_phrase`. Она будет использовать `duckduckgo-search` для поиска картинок (`ddgs.images()`).
    *   Функция скачает **одну** самую релевантную картинку, сохранит ее в `assets/images` и вернет путь к ней.
    *   Изменим `enrich_phrase`, чтобы она вызывала эту новую функцию.
3.  **Парсинг Примеров из Словаря (Reverso Context):**
    *   Создадим новый парсер `reverso_parser.py` в `core/`.
    *   Он будет ходить на `context.reverso.net`, искать там нашу ключевую фразу и "вытаскивать" 5-7 качественных примеров использования. Этот источник гораздо надежнее, чем общий поиск в DuckDuckGo.
    *   `enrichment.py` будет вызывать этот парсер вместо старого `find_usage_examples`.
4.  **UI для Подтверждения Примеров:**
    *   На экране `CreationScreen`, после обогащения, вместо автоматического отображения результатов мы будем показывать новый "промежуточный" экран или диалоговое окно.
    *   В нем будет список найденных примеров с `checkbox`'ами или кнопками "удалить". Пользователь сможет просмотреть примеры и убрать неподходящие перед сохранением.

---

#### **Шаг 8: Редизайн и Улучшение Тренировки**

**Цель:** Сделать приложение красивее и внедрить новый, более эффективный режим тренировки.

1.  **Новый тип карточки "Понимание на слух/в контексте":**
    *   В `DatabaseManager._generate_cards_for_concept` добавим создание нового типа карточки (`comprehension`). `front` будет содержать один из примеров, а `back` — перевод ключевой фразы.
2.  **Редизайн Экрана Тренировки:**
    *   Полностью переделаем `TrainingScreen`.
    *   При показе карточки типа `comprehension`:
        *   Вверху показываем **картинку**, связанную с концептом.
        *   Под ней — **кнопка "Play"** для прослушивания аудио примера.
        *   Ниже — сам **текст примера** с пропуском (`... a blessing in ______`).
    *   По кнопке "Показать ответ" открывается вся фраза целиком и ее перевод.
3.  **Внедрение "Вайба" Duolingo:**
    *   **Цветовая схема:** Изменим `primary_palette` в `main.py` на более яркую (например, `Green` или `Teal`).
    *   **Стиль карточек:** В KV-разметке `TrainingScreen` стилизуем `MDCard`, добавив им `radius` (закругленные углы) и `line_color`.
    *   **Звуковые эффекты:** Добавим в `assets/audio` два коротких звука: `correct.mp3` и `wrong.mp3`. В `TrainingScreen`, в методе `evaluate_answer`, будем проигрывать соответствующий звук при оценке "хорошо/легко" или "снова". Kivy имеет простой API для проигрывания звуков.

---

**Итог плана:**

*   **Шаг 6: Бэкенд для языков.** Основа для дальнейшего развития.
*   **Шаг 7: Улучшение контента.** Делаем каждую карточку в 10 раз ценнее.
*   **Шаг 8: UI/UX.** Делаем приложение приятным и эффективным в использовании.

