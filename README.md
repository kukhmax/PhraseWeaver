### Общий План разработки (Roadmap)

#  версия python 3.11.9 !!!!

Прежде чем мы напишем первую строчку кода, я хочу обозначить общую последовательность наших действий, чтобы у вас было полное понимание процесса:

Шаг 0: Подготовка рабочего окружения и структуры проекта. Создадим фундамент: папки, базовые файлы, настроим виртуальное окружение. (Наш текущий шаг)

Шаг 1: Создание слоя для работы с базой данных. Напишем код, который будет управлять таблицами SQLite, чтобы остальное приложение могло легко сохранять и получать данные.

    Резюме шага 1:

    Мы создали изолированный модуль для работы с базой данных (core/database.py).
    При первом запуске он автоматически создает всю необходимую структуру таблиц согласно ТЗ.
    Мы реализовали базовые функции для создания и получения списка колод.
    Приложение теперь корректно управляет жизненным циклом соединения с БД (открывает при старте, закрывает при выходе).
    Мы использовали лучшие практики: логирование, обработку ошибок, автоматическое управление транзакциями и row_factory для удобного получения данных.

Шаг 2: Разработка базового UI на Kivy/KivyMD. Создадим главный экран "Колоды" и настроим навигацию между экранами. Пока без логики.

    Резюме шага 2:
    
    Мы создали архитектуру для многоэкранного приложения с помощью ScreenManager.
    Мы вынесли дизайн и логику первого экрана (DeckListScreen) в отдельный файл, следуя лучшим практикам.
    Мы научились отделять структуру интерфейса (KV-язык) от логики на Python.
    Наше приложение теперь не просто запускается, а показывает реальные данные из базы данных, динамически строя по ним список.
    Мы заложили основу для навигации — при нажатии на колоду мы уже можем отследить это событие.


Шаг 3: Разработка модуля "Обогащения". Напишем ядро нашего приложения — код, который будет ходить в интернет за переводами, примерами и аудио. Мы сделаем его полностью независимым от интерфейса.

    Резюме шага 3:

    Перевод успешно получен.
    Аудио для фразы и перевода сгенерировано.
    Приложение столкнулось с Ratelimit от DuckDuckGo. Это нормальное поведение, и наш код правильно его обработал: он не упал, а вежливо сообщил об ошибке и вернул пустой список примеров. Это как раз та надежность, к которой мы стремились. В реальном использовании такие лимиты срабатывают редко.
    Программа завершилась корректно и собрала все данные, которые смогла получить.

Шаг 4: Интеграция. Экран создания карточки. Свяжем UI и модуль "Обогащения". Создадим экран, где пользователь сможет вводить фразу и запускать процесс обогащения контента.

    Резюме шага 4:

    1. Создали новый Экран "Создания Карточки":
        - Разработали UI (CreationScreen) с полями для ввода полного предложения и ключевой фразы.
        - Разместили на нем кнопки для запуска процесса ("Обогатить") и сохранения результата ("Сохранить в колоду").
    2. Реализовали главную "фишку" приложения — асинхронное обогащение:
        - Написали логику, которая по нажатию кнопки "Обогатить ✨" запускает наш enrichment.py в отдельном фоновом потоке.
        - Это гарантирует, что интерфейс приложения никогда не "зависает", даже если поиск перевода или примеров занимает много времени. Пользователь всегда может взаимодействовать с приложением.
    3. Создали интуитивно понятный пользовательский опыт (UX) для долгой операции:
        - При запуске обогащения кнопка становится неактивной, и появляется индикатор загрузки (спиннер). Пользователь визульно понимает, что идет работа.
        - После завершения процесса спиннер исчезает, и на экране появляются результаты (перевод и примеры) в виде интерактивных кнопок.
        - Кнопка "Сохранить" активируется только после успешного получения данных, что логично и предотвращает сохранение пустых карточек.
    4. Наладили навигацию:
        - Теперь с главного экрана (DeckListScreen) можно перейти на экран создания, нажав плавающую кнопку "+".
        - С экрана создания можно вернуться назад, используя системную кнопку "назад" или стрелку в левом верхнем углу.
    5. Провели масштабную отладку и адаптацию:
        - Мы столкнулись с реальными проблемами разработки: несовместимость версий библиотек (translators, httpx), различия в версиях Python.
        - Мы успешно обновили фреймворк KivyMD до последней версии и адаптировали весь наш UI-код к его новому API, исправив множество ошибок импорта и использования виджетов.
        - Мы отладили сложную логику управления состоянием UI (вечные спиннеры), сделав ее надежной.

Шаг 5: Реализация алгоритма SRS и экрана тренировки. Создадим логику интервальных повторений и интерфейс для прохождения карточек.

    Резюме шага 5:

    1. "Оживили" кнопку "Сохранить":
        - Расширили наш DatabaseManager новыми методами, которые теперь умеют сохранять не только колоды, но и сложные "Концепты" (фраза, перевод, примеры, аудио) и связанные с ними тренировочные карточки.
        - Реализовали проверку на дубликаты: приложение не позволит сохранить одну и ту же ключевую фразу дважды.
    2. Автоматизировали создание учебного материала:
        - Написали логику, которая из одного созданного пользователем "Концепта" автоматически генерирует до трех разных тренировочных карточек (прямая, обратная, заполнение пропуска). Это ядро нашего УТП — максимальная автоматизация для пользователя.
    3.Создали мозг системы — алгоритм интервальных повторений (SRS):
        - Разработали отдельный, чистый модуль core/srs.py.
        - В нем реализовали функцию calculate_next_due_date, которая на основе оценки пользователя ("Снова", "Хорошо", "Легко") вычисляет, когда нужно показать карточку в следующий раз. Это обеспечивает эффективное долгосрочное запоминание.
    4. Построили "Тренажерный зал" — Экран Тренировки:
        - Создали TrainingScreen — главный экран, где происходит обучение.
        - Он запрашивает из БД только те карточки, у которых подошло время повторения (due_date <= сегодня).
        - Реализовали классический интерфейс "вопрос-ответ": показ "лица" карточки, затем по кнопке — "оборота".
        - Интегрировали кнопки оценки с нашим SRS-алгоритмом. После каждой оценки карточка обновляется в БД с новой датой повторения.
    5. Сделали главный экран информативным:
        - Экран со списком колод (DeckListScreen) теперь не просто показывает названия, а выводит счетчик карточек, готовых к повторению в каждой колоде.
        - Нажатие на колоду теперь запускает сеанс тренировки, если в ней есть что повторять.

Шаг 6: Финальная полировка и сборка. Добавим обработку ошибок, "умную" вставку из буфера обмена и подготовим все для сборки в .apk файл.

Этот план гибок, но он дает нам четкое направление. Начнем с самого начала.