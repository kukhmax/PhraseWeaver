### Общий План разработки (Roadmap)

#  версия python 3.11.9 !!!!

Прежде чем мы напишем первую строчку кода, я хочу обозначить общую последовательность наших действий, чтобы у вас было полное понимание процесса:

Шаг 0: Подготовка рабочего окружения и структуры проекта. Создадим фундамент: папки, базовые файлы, настроим виртуальное окружение. (Наш текущий шаг)

Шаг 1: Создание слоя для работы с базой данных. Напишем код, который будет управлять таблицами SQLite, чтобы остальное приложение могло легко сохранять и получать данные.

    Резюме шага 1:

    Мы создали изолированный модуль для работы с базой данных (core/database.py).
    При первом запуске он автоматически создает всю необходимую структуру таблиц согласно ТЗ.
    Мы реализовали базовые функции для создания и получения списка колод.
    Приложение теперь корректно управляет жизненным циклом соединения с БД (открывает при старте, закрывает при выходе).
    Мы использовали лучшие практики: логирование, обработку ошибок, автоматическое управление транзакциями и row_factory для удобного получения данных.

Шаг 2: Разработка базового UI на Kivy/KivyMD. Создадим главный экран "Колоды" и настроим навигацию между экранами. Пока без логики.

    Резюме шага 2:
    
    Мы создали архитектуру для многоэкранного приложения с помощью ScreenManager.
    Мы вынесли дизайн и логику первого экрана (DeckListScreen) в отдельный файл, следуя лучшим практикам.
    Мы научились отделять структуру интерфейса (KV-язык) от логики на Python.
    Наше приложение теперь не просто запускается, а показывает реальные данные из базы данных, динамически строя по ним список.
    Мы заложили основу для навигации — при нажатии на колоду мы уже можем отследить это событие.


Шаг 3: Разработка модуля "Обогащения". Напишем ядро нашего приложения — код, который будет ходить в интернет за переводами, примерами и аудио. Мы сделаем его полностью независимым от интерфейса.

    Резюме шага 3:

    Перевод успешно получен.
    Аудио для фразы и перевода сгенерировано.
    Приложение столкнулось с Ratelimit от DuckDuckGo. Это нормальное поведение, и наш код правильно его обработал: он не упал, а вежливо сообщил об ошибке и вернул пустой список примеров. Это как раз та надежность, к которой мы стремились. В реальном использовании такие лимиты срабатывают редко.
    Программа завершилась корректно и собрала все данные, которые смогла получить.

Шаг 4: Интеграция. Экран создания карточки. Свяжем UI и модуль "Обогащения". Создадим экран, где пользователь сможет вводить фразу и запускать процесс обогащения контента.

    Резюме шага 4:

    1. Создали новый Экран "Создания Карточки":
        - Разработали UI (CreationScreen) с полями для ввода полного предложения и ключевой фразы.
        - Разместили на нем кнопки для запуска процесса ("Обогатить") и сохранения результата ("Сохранить в колоду").
    2. Реализовали главную "фишку" приложения — асинхронное обогащение:
        - Написали логику, которая по нажатию кнопки "Обогатить ✨" запускает наш enrichment.py в отдельном фоновом потоке.
        - Это гарантирует, что интерфейс приложения никогда не "зависает", даже если поиск перевода или примеров занимает много времени. Пользователь всегда может взаимодействовать с приложением.
    3. Создали интуитивно понятный пользовательский опыт (UX) для долгой операции:
        - При запуске обогащения кнопка становится неактивной, и появляется индикатор загрузки (спиннер). Пользователь визульно понимает, что идет работа.
        - После завершения процесса спиннер исчезает, и на экране появляются результаты (перевод и примеры) в виде интерактивных кнопок.
        - Кнопка "Сохранить" активируется только после успешного получения данных, что логично и предотвращает сохранение пустых карточек.
    4. Наладили навигацию:
        - Теперь с главного экрана (DeckListScreen) можно перейти на экран создания, нажав плавающую кнопку "+".
        - С экрана создания можно вернуться назад, используя системную кнопку "назад" или стрелку в левом верхнем углу.
    5. Провели масштабную отладку и адаптацию:
        - Мы столкнулись с реальными проблемами разработки: несовместимость версий библиотек (translators, httpx), различия в версиях Python.
        - Мы успешно обновили фреймворк KivyMD до последней версии и адаптировали весь наш UI-код к его новому API, исправив множество ошибок импорта и использования виджетов.
        - Мы отладили сложную логику управления состоянием UI (вечные спиннеры), сделав ее надежной.

Шаг 5: Реализация алгоритма SRS и экрана тренировки. Создадим логику интервальных повторений и интерфейс для прохождения карточек.

    Резюме шага 5:

    1. "Оживили" кнопку "Сохранить":
        - Расширили наш DatabaseManager новыми методами, которые теперь умеют сохранять не только колоды, но и сложные "Концепты" (фраза, перевод, примеры, аудио) и связанные с ними тренировочные карточки.
        - Реализовали проверку на дубликаты: приложение не позволит сохранить одну и ту же ключевую фразу дважды.
    2. Автоматизировали создание учебного материала:
        - Написали логику, которая из одного созданного пользователем "Концепта" автоматически генерирует до трех разных тренировочных карточек (прямая, обратная, заполнение пропуска). Это ядро нашего УТП — максимальная автоматизация для пользователя.
    3.Создали мозг системы — алгоритм интервальных повторений (SRS):
        - Разработали отдельный, чистый модуль core/srs.py.
        - В нем реализовали функцию calculate_next_due_date, которая на основе оценки пользователя ("Снова", "Хорошо", "Легко") вычисляет, когда нужно показать карточку в следующий раз. Это обеспечивает эффективное долгосрочное запоминание.
    4. Построили "Тренажерный зал" — Экран Тренировки:
        - Создали TrainingScreen — главный экран, где происходит обучение.
        - Он запрашивает из БД только те карточки, у которых подошло время повторения (due_date <= сегодня).
        - Реализовали классический интерфейс "вопрос-ответ": показ "лица" карточки, затем по кнопке — "оборота".
        - Интегрировали кнопки оценки с нашим SRS-алгоритмом. После каждой оценки карточка обновляется в БД с новой датой повторения.
    5. Сделали главный экран информативным:
        - Экран со списком колод (DeckListScreen) теперь не просто показывает названия, а выводит счетчик карточек, готовых к повторению в каждой колоде.
        - Нажатие на колоду теперь запускает сеанс тренировки, если в ней есть что повторять.

Шаг 6: Финальная полировка и сборка. Добавим обработку ошибок, "умную" вставку из буфера обмена и подготовим все для сборки в .apk файл.

О

### **Roadmap разработки PhraseWeaver v2.0**

Наша цель — превратить рабочий прототип в более умный, красивый и функциональный инструмент.

**Общая стратегия:** Мы будем двигаться от "невидимых" бэкенд-изменений к видимым для пользователя UI/UX улучшениям.

---

#### **Шаг 6: Мультиязычность и Умные Колоды**

**Цель:** Научить приложение работать с несколькими языками, привязав язык к колоде.

1.  **Модификация Базы Данных:**
    *   Добавим в таблицу `decks` новое поле: `lang_code TEXT NOT NULL DEFAULT 'en'`.
    *   Обновим метод `DatabaseManager.create_deck`, чтобы он принимал и сохранял код языка.
2.  **Обновление UI Создания Колоды:**
    *   Сейчас у нас нет отдельного UI для создания колоды (мы делали это в коде). Пора его создать!
    *   На экране `DeckListScreen` изменим кнопку `+`. Теперь она будет открывать простое диалоговое окно, где пользователь вводит `имя новой колоды` и **выбирает язык** из выпадающего списка (`Английский`, `Испанский`, `Португальский`).
3.  **Интеграция в Процесс Обогащения:**
    *   Когда пользователь добавляет карточку в "Испанскую" колоду, `CreationScreen` будет передавать `lang_code='es'` в наш модуль `enrichment.py`.
    *   `enrichment.py` будет использовать этот код для:
        *   **Перевода:** `googletrans` будет переводить с `src='es'` на `dest='ru'`.
        *   **Озвучки:** `gTTS` будет генерировать аудио с `lang='es'`.
4.  **Реализация "Умного бонуса":**
    *   В `CreationScreen`, после ввода фразы, незаметно вызовем `googletrans.detect()`. Если определенный язык не совпадает с языком колоды, покажем маленькую иконку-предупреждение или ненавязчивое уведомление (`Snackbar`) с текстом: "Похоже, это португальский. Все равно добавить в испанскую колоду?".

---

#### **Шаг 7: Расширенное Обогащение — Картинки и Контекст**


### **Шаг 7 (v3.0): Интерактивное Обогащение с Визуальным Подтверждением**

**Общая Цель:** Создать процесс, в котором пользователь вводит ключевое слово, получает на выбор список готовых фраз-примеров с переводом **И** картинку-ассоциацию, утверждает всё это, и одним нажатием сохраняет в колоду набор визуально подкрепленных карточек.

---

#### **Шаг 7.1: Backend — Двойной Удар (Фразы + Картинка)**

**Цель:** Научить систему одновременно искать и текстовые примеры, и визуальный образ.

1.  **Парсер Reverso Context (Без изменений):**
    *   Задача: Создать `core/reverso_parser.py` с функцией `find_examples_on_reverso`.
    *   Результат: Возвращает список словарей `[{'original': ..., 'translation': ...}]`. Эту часть плана мы сохраняем.

2.  **Поиск Картинки (Новая задача):**
    *   Задача: Добавить в `core/enrichment.py` новую асинхронную функцию `find_image_for_keyword(keyword)`.
    *   **Действия:**
        *   Она будет использовать библиотеку `duckduckgo-search`, которая у нас уже есть в `requirements.txt`.
        *   Она выполнит асинхронный поиск по картинкам: `AsyncDDGS().images(keyword)`.
        *   Она скачает **одну**, самую первую и самую релевантную картинку.
        *   Она сохранит ее в папку `assets/images/` (нужно будет убедиться, что папка создается при старте приложения).
        *   **Результат:** Функция вернет локальный путь к скачанному файлу, например `'assets/images/my_keyword_image.jpg'`.

---

#### **Шаг 7.2: Frontend — Экран Курирования "Все-в-одном"**

**Цель:** Полностью перепроектировать новый экран `CurationScreen`, чтобы на нем можно было утверждать и фразы, и картинку.

1.  **Создание `CurationScreen.py` и разметка в `main.py`:**
    *   В `KV` мы опишем новую структуру экрана.
    *   **Верхняя часть:** Здесь будет `MDCard` для предпросмотра изображения. Внутри него — виджет `FitImage` или `Image`, который будет отображать найденную картинку. Рядом с ним можно добавить маленькие кнопки-иконки "Найти другую" и "Без картинки".
    *   **Нижняя часть:** Под карточкой с картинкой будет `ScrollView` со списком `MDList` наших пар фраз (оригинал + перевод). Как и планировалось, у каждой пары будет кнопка "Удалить".
    *   **Финальная кнопка:** В самом низу — "Добавить выбранное в колоду".

---

#### **Шаг 7.3: Logic — Перестройка Пользовательского Пути**

**Цель:** Оркестрировать новый, более сложный процесс получения, подтверждения и сохранения данных.

1.  **Изменяем `creation_screen.py`:**
    *   Метод `enrich_button_pressed` теперь — дирижер.
    *   Он **одновременно** запускает `find_examples_on_reverso` и `find_image_for_keyword` (с помощью `asyncio.gather` для параллельного выполнения).
    *   Он получает от них два результата: `список_фраз` и `путь_к_картинке`.
    *   Он передает **оба** этих результата на `CurationScreen` и переключает на него вид.

2.  **Пишем логику `CurationScreen.py`:**
    *   `on_enter` принимает `список_фраз` и `путь_к_картинке`. Он заполняет и `MDList` списком фраз, и `Image` в верхней части экрана.
    *   Логика кнопки "Удалить фразу" остается прежней.
    *   **Ключевой метод "Добавить выбранное":**
        1.  Он считывает финальный `путь_к_картинке` из виджета `Image`.
        2.  Он проходит по всем **оставшимся** элементам списка фраз.
        3.  Для **каждого** элемента он:
            *   Берет `original` и `translation`.
            *   Формирует `enriched_data` для этого конкретного концепта.
            *   **ВАЖНО:** Добавляет в этот словарь `путь_к_картинке`: `enriched_data['image_path'] = путь_к_картинке`.
            *   Вызывает `db_manager.create_concept_and_cards` с этими данными.
        4.  После цикла показывает `Snackbar` и возвращается на главный экран.

---

#### **Шаг 7.4: Database — Подготовка к хранению картинок**

**Цель:** Расширить нашу базу данных, чтобы она могла хранить информацию об изображениях.

1.  **Изменяем `core/database.py`:**
    *   **SQL:** В методе, который создает таблицу `concepts`, мы добавляем новое поле: `image_path TEXT DEFAULT NULL`.
    *   **Логика:** В методе `create_concept_and_cards` (или его аналоге) мы модифицируем `INSERT`-запрос. Теперь он должен проверять, есть ли в словаре `enriched_data` ключ `image_path`, и если есть — вставлять это значение в новую колонку.

---

#### **Шаг 8: Редизайн и Улучшение Тренировки**

**Цель:** Сделать приложение красивее и внедрить новый, более эффективный режим тренировки.

1.  **Новый тип карточки "Понимание на слух/в контексте":**
    *   В `DatabaseManager._generate_cards_for_concept` добавим создание нового типа карточки (`comprehension`). `front` будет содержать один из примеров, а `back` — перевод ключевой фразы.
2.  **Редизайн Экрана Тренировки:**
    *   Полностью переделаем `TrainingScreen`.
    *   При показе карточки типа `comprehension`:
        *   Вверху показываем **картинку**, связанную с концептом.
        *   Под ней — **кнопка "Play"** для прослушивания аудио примера.
        *   Ниже — сам **текст примера** с пропуском (`... a blessing in ______`).
    *   По кнопке "Показать ответ" открывается вся фраза целиком и ее перевод.
3.  **Внедрение "Вайба" Duolingo:**
    *   **Цветовая схема:** Изменим `primary_palette` в `main.py` на более яркую (например, `Green` или `Teal`).
    *   **Стиль карточек:** В KV-разметке `TrainingScreen` стилизуем `MDCard`, добавив им `radius` (закругленные углы) и `line_color`.
    *   **Звуковые эффекты:** Добавим в `assets/audio` два коротких звука: `correct.mp3` и `wrong.mp3`. В `TrainingScreen`, в методе `evaluate_answer`, будем проигрывать соответствующий звук при оценке "хорошо/легко" или "снова". Kivy имеет простой API для проигрывания звуков.

---

**Итог плана:**

*   **Шаг 6: Бэкенд для языков.** Основа для дальнейшего развития.
*   **Шаг 7: Улучшение контента.** Делаем каждую карточку в 10 раз ценнее.
*   **Шаг 8: UI/UX.** Делаем приложение приятным и эффективным в использовании.

Три Режима Тренировки в Одной Сессии**

Вместо того чтобы делать только два типа "вопрос-ответ", мы можем легко реализовать три, которые будут случайно перемешиваться и тренировать разные навыки:

1.  **"Классическая Карточка" (Распознавание):**
    *   **Показываем:** Фразу на иностранном + картинку + кнопку "Play".
    *   **Действие:** Пользователь нажимает "Показать перевод".
    *   **Тренирует:** Пассивное узнавание. Самый легкий режим, идеален для знакомства с фразой.

2.  **"Перевод-Спринт" (Активное Воспроизведение):**
    *   **Показываем:** Перевод на русском + картинку.
    *   **Действие:** Пользователь должен **напечатать** фразу на иностранном языке. Мы сравниваем и показываем галочку/крестик.
    *   **Тренирует:** Активную память. Самый сложный и самый эффективный режим для запоминания.

3.  **"Понимание в Контексте" (Новый режим!):**
    *   **Показываем:** Одну из фраз-примеров, которые нашел AI, но с **пропуском** на месте ключевого слова (например, `I am going ______ after work.`) + картинку + кнопку "Play".
    *   **Действие:** Пользователь должен **напечатать** пропущенное ключевое слово.
    *   **Тренирует:** Понимание контекста и правильное использование слова. Это — высший пилотаж.

Эта система превращает каждую тренировку в непредсказуемый и увлекательный процесс, который не дает мозгу заскучать.

### **План Дальнейших Действий: Перестройка Тренажерного Зала**

Это большой, но очень захватывающий шаг. Мы полностью переделаем `TrainingScreen`. Давай разобьем его на логичные этапы.

---

#### **Шаг 10: Бэкенд и Данные — Готовим "Патроны" для Тренировки**

**Цель:** Научить `DatabaseManager` создавать новые, более "умные" типы карточек, которые нужны для наших новых режимов.

1.  **Модификация `_generate_cards_for_concept`:**
    *   Откроем `core/database.py`.
    *   Мы сильно изменим метод `_generate_cards_for_concept`. Теперь для **каждого** "концепта" (то есть для каждой фразы-примера) он будет создавать не две, а **три** карточки в базе данных:
        *   `type='direct'`: `front` = иностранная фраза, `back` = перевод.
        *   `type='reverse_recall'`: `front` = перевод, `back` = иностранная фраза.
        *   `type='context_cloze'`: `front` = `{ "context": "I am going ... after work.", "audio": "path/to/audio.mp3" }`, `back` = `home`. (Мы будем хранить данные в формате JSON прямо в текстовых полях).

---

#### **Ша- 11: Frontend — Строим новый, интерактивный интерфейс `TrainingScreen`**

**Цель:** Полностью переписать разметку `KV` для экрана тренировки, чтобы на нем были все нужные нам элементы.

1.  **Редизайн в `main.py`:**
    *   Откроем `main.py` и найдем блок `<TrainingScreen>`.
    *   Мы добавим в него:
        *   `MDTopAppBar` с `MDProgressBar` внутри.
        *   Главную `MDCard` для "вопроса". В ней будет `FitImage` для картинки, `MDLabel` для текста/контекста и `MDIconButton` для проигрывания аудио.
        *   Область "ответа", которая будет меняться. В ней будут:
            *   `MDLabel` (для показа ответа в "классическом" режиме).
            *   `MDTextField` (для ввода ответа в режимах "Спринт" и "Контекст").
            *   `MDIconButton` (для иконки галочки/крестика).
        *   Нижняя панель с кнопками оценки SRS ("Снова", "Хорошо", "Легко"), которые изначально будут скрыты.

---

#### **Шаг 12: Logic — Пишем "Мозг" Тренажера**

**Цель:** Реализовать всю логику в `screens/training_screen.py`.

1.  **Полная переработка `TrainingScreen`:**
    *   **`on_enter`:** Загружаем **все** доступные для повторения карточки из колоды и **перемешиваем** их (`random.shuffle`).
    *   **`show_next_card()`:** Это будет главный метод-дирижер.
        *   Берет следующую карточку из перемешанного списка.
        *   Смотрит на ее `card_type`.
        *   В зависимости от типа, вызывает соответствующий метод настройки: `_setup_classic_card()`, `_setup_recall_card()` или `_setup_context_card()`.
    *   **Методы настройки (`_setup_...`)**: Каждый из этих методов будет настраивать UI под конкретную задачу (показывать/прятать `MDTextField`, менять текст на кнопках и т.д.).
    *   **`check_answer()` (Новый метод):** Будет вызываться, когда пользователь ввел текст в `MDTextField`. Он сравнит ввод с правильным ответом в `card['back']`, покажет галочку или крестик, а затем покажет кнопки оценки SRS.
    *   **`evaluate_answer()`:** Этот метод почти не изменится. Он, как и раньше, будет отвечать за расчет SRS и вызов `show_next_card()` для перехода к следующему испытанию.



---

### **Roadmap: Фаза "Мотивация"**

**Общая цель:** Создать новый раздел в приложении, который будет наглядно показывать пользователю его достижения и мотивировать его на регулярные занятия.

---

#### **Шаг 13: Бэкенд — Учим Базу Данных вести "Дневник Успеха"**

**Цель:** Расширить нашу БД, чтобы она могла отслеживать историю повторений. Это — фундамент для всей статистики.

1.  **Создание новой таблицы `review_history`:**
    *   Откроем `core/database.py`.
    *   В методе `_init_db` мы добавим SQL-код для создания новой таблицы. В ней будет всего три колонки: `id`, `card_id` и, самое главное, `review_date` (дата и время, когда карточка была повторена).

2.  **Интеграция с процессом тренировки:**
    *   Мы немного изменим метод `update_card_srs` в `database.py`. Теперь, каждый раз, когда пользователь оценивает карточку (нажимает "Снова", "Хорошо" или "Легко"), этот метод будет не только обновлять саму карточку, но и делать одну маленькую запись в `review_history`, фиксируя сам факт повторения.

3.  **Создание новых "статистических" методов:**
    *   Мы добавим в `DatabaseManager` несколько новых, мощных методов для сбора статистики:
        *   `get_reviews_per_day(days=7)`: Будет считать, сколько карточек было повторено в каждый из последних 7 дней. Это — данные для нашего будущего графика.
        *   `get_study_streak()`: Самый интересный метод. Он будет смотреть в `review_history` и считать, сколько дней подряд пользователь занимался без перерывов. Это и есть "ударная серия".
        *   `count_learned_cards()`: Будет считать количество "выученных" карточек (например, тех, у которых интервал повторения больше 21 дня).
        *   `get_upcoming_reviews_count()`: Будет считать, сколько карточек предстоит повторить в ближайшую неделю.

---

#### **Шаг 14: Установка Библиотеки для Графиков**

**Цель:** Интегрировать в проект простой, но красивый инструмент для построения графиков.

1.  **Установка `kivy-garden.graph`:**
    *   Это специальный пакет для Kivy, который устанавливается отдельной командой. Мы откроем терминал (с активированным `.venv`) и выполним:
        ```bash
        kivy-garden install graph
        ```
    *   Это добавит в наш проект возможность легко рисовать графики и диаграммы.

---

#### **Шаг 15: Frontend — Проектируем Экран Статистики**

**Цель:** Создать новый, красивый экран, где будет отображаться вся собранная информация.

1.  **Создание `screens/stats_screen.py`:** Создадим Python-файл для логики нового экрана.
2.  **Регистрация экрана в `main.py`:** Добавим новый экран в `ScreenManager` и в `KV`-разметку.
3.  **Добавление кнопки перехода:** На главном экране (`DeckListScreen`) в верхней панели (`MDTopAppBar`) мы добавим новую иконку (например, `chart-timeline-variant`), по нажатию на которую будем переходить на экран статистики.
4.  **Проектирование разметки `<StatsScreen>` в `main.py`:**
    *   `MDTopAppBar` с кнопкой "Назад".
    *   `ScrollView`, чтобы экран хорошо смотрелся на любых устройствах.
    *   **Карточки для ключевых показателей:**
        *   Одна `MDCard` вверху, где будут три больших показателя: **Карточек выучено**, **Ударная серия** и **Предстоит на неделе**.
    *   **Карточка для графика:**
        *   Вторая, большая `MDCard`, внутри которой мы оставим пустое место (`BoxLayout` с `id: graph_container`). Сюда мы будем динамически вставлять наш график.

---

#### **Ша- 16: Logic — Оживляем Статистику**

**Цель:** Написать код в `screens/stats_screen.py`, который будет запрашивать данные из БД и строить график.

1.  **`on_enter` — главный метод:**
    *   При входе на экран этот метод будет вызывать все наши новые "статистические" методы из `DatabaseManager`.
    *   Он обновит тексты на карточках с ключевыми показателями.
2.  **Построение графика:**
    *   Мы получим данные от `get_reviews_per_day`.
    *   Создадим объект `Graph` из библиотеки `kivy-garden.graph`.
    *   Настроим его внешний вид (подписи осей, цвета).
    *   Создадим `LinePlot` (линейный график) и передадим ему наши точки данных.
    *   Добавим график на экран в наш `graph_container`.




### **Мозговой Штурм: От Жесткой Логики к Гибким Настройкам**

**Проблема №1: "Добавить польский язык".**
*   **Техническая сторона:** Это легко. Добавить одну строчку в конфиг.
*   **Глубинная сторона:** А что, если завтра мы захотим добавить немецкий? А послезавтра — китайский? Каждый раз лезть в код? Нет. Нам нужна система, которая позволит **легко** добавлять новые языки.

**Проблема №2: "Выбор главного языка".**
*   **Техническая сторона:** Сейчас язык перевода жестко "зашит" в коде (`dest='ru'`). Нам нужно заменить это на переменную, которую выберет пользователь.
*   **Глубинная сторона:** Это фундаментально меняет логику приложения. Оно перестает быть "русскоязычным" по умолчанию. Теперь это **международный** инструмент, где любой человек может учить любой язык, используя свой родной как базу. Это — мощнейший шаг.

### **Мое предложение: Единый Экран Настроек**

Вместо того чтобы добавлять эти функции по-отдельности, давай создадим единый центр управления приложением — **Экран Настроек**. Это решит текущие задачи и откроет двери для будущих улучшений.

На этом экране пользователь сможет:
1.  **Выбрать язык интерфейса** (пока не будем это реализовывать, но заложим фундамент).
2.  **Выбрать свой "родной" язык** (тот, на который будут переводиться все фразы).
3.  **Управлять списком изучаемых языков** (включать/выключать их видимость, например).

Это делает приложение невероятно гибким и готовым к будущему росту.

---

### **План Разработки: Фаза "Кастомизация"**

**Цель:** Дать пользователю контроль над языковыми настройками приложения.

#### **Шаг 17: Бэкенд — Создаем "Хранилище Настроек"**

**Цель:** Создать простое, но надежное место для хранения пользовательских настроек, чтобы они не сбрасывались после перезапуска.

1.  **Новая таблица `settings`:**
    *   Откроем `core/database.py`. В методе `_init_db` добавим создание новой таблицы. Она будет очень простой: `key TEXT PRIMARY KEY, value TEXT`.
    *   В ней мы будем хранить настройки, например: `('target_language', 'ru')`, `('theme', 'Light')` и т.д.

2.  **Новые методы в `DatabaseManager`:**
    *   `get_setting(key, default=None)`: Будет получать значение настройки по ключу.
    *   `set_setting(key, value)`: Будет сохранять или обновлять настройку.
    *   При первом запуске приложения мы будем инициализировать `target_language` значением `'ru'` по умолчанию.

3.  **Добавляем польский язык:**
    *   Откроем `core/config.py` и просто добавим `'pl': 'Polish'` в словарь `SUPPORTED_LANGUAGES`.

---

#### **Шаг 18: Frontend — Проектируем Экран Настроек**

**Цель:** Создать красивый и понятный интерфейс, где пользователь сможет менять настройки.

1.  **Создаем `screens/settings_screen.py`**.
2.  **Регистрируем новый экран** в `main.py` и добавляем кнопку для перехода на него на главном экране (например, иконка-шестеренка в `TopAppBar`).
3.  **Проектируем разметку `<SettingsScreen>` в `main.py`:**
    *   `MDTopAppBar` с кнопкой "Назад".
    *   Подзаголовок "Языковые настройки".
    *   **Элемент выбора "Мой родной язык":**
        *   Мы используем `TwoLineListItem` или похожий виджет.
        *   В первой строке будет "Я перевожу на:", а во второй (`secondary_text`) — текущий выбранный язык (например, "Русский").
        *   При нажатии на этот элемент будет открываться простое диалоговое окно (`MDDialog`) со списком всех доступных языков, где пользователь сможет выбрать новый "главный" язык.

---

#### **Шаг 19: Logic — Интегрируем Настройки во все Части Приложения**

**Цель:** Заставить все наши "мозги" (AI, переводчик, `CurationScreen`) уважать выбор пользователя.

1.  **Обновляем `core/enrichment.py`:**
    *   Главная функция `enrich_phrase` теперь должна будет принимать новый аргумент — `target_lang`.
    *   Вместо жестко прописанного `dest='ru'` в `googletrans` и `'russian'` в промпте для AI, мы будем использовать этот `target_lang`.

2.  **Обновляем `screens/creation_screen.py`:**
    *   Перед тем как запустить обогащение, метод `enrich_button_pressed` должен будет "спросить" у базы данных: "А какой у пользователя `target_language`?".
    *   Он вызовет `db_manager.get_setting('target_language', 'ru')`.
    *   И передаст этот язык в `enrich_phrase`.

3.  **Обновляем `screens/settings_screen.py`:**
    *   **`on_enter`:** При входе на экран он будет загружать из БД текущий `target_language` и отображать его.
    *   **Логика диалогового окна:** При выборе нового языка в диалоговом окне мы будем вызывать `db_manager.set_setting('target_language', new_lang_code)`, сохраняя выбор пользователя, а затем обновлять текст на экране.




**Проблема:** Весь текст в нашем приложении (названия кнопок, заголовки, подсказки) "зашит" прямо в `.kv` файлах: `text: "Проверить"`, `hint_text: "Ваш ответ..."`. Нам нужен способ **динамически** подставлять сюда текст в зависимости от выбранного языка.

**Решение:** Мы создадим собственную, очень простую систему переводов, используя стандартные возможности Python — **словари**. Мы не будем использовать тяжелые библиотеки, чтобы не усложнять проект.

---

### **План Разработки: Фаза "Интернационализация" (i18n)**

#### **Шаг 20: Бэкенд — Создаем "Словари" для Переводов**

**Цель:** Создать центральное место, где будут храниться все переводы строк интерфейса.

1.  **Создание `core/localization.py`:**
    *   Мы создадим новый файл, который будет нашим "многоязычным словарем".
    *   Внутри него будет главная структура данных — словарь словарей:

    ```python
    # в core/localization.py
    TRANSLATIONS = {
        'ru': {
            'training': 'Тренировка',
            'check_answer': 'Проверить',
            'show_answer': 'Показать ответ',
            'your_answer': 'Ваш ответ...',
            'deck_list_title': 'PhraseWeaver',
            # ... и так далее для КАЖДОЙ строки в приложении
        },
        'en': {
            'training': 'Training',
            'check_answer': 'Check Answer',
            'show_answer': 'Show Answer',
            'your_answer': 'Your answer...',
            'deck_list_title': 'PhraseWeaver',
            # ...
        },
        # В будущем добавим 'pl', 'es' и т.д.
    }
    ```

2.  **Создание функции-переводчика `t`:**
    *   В том же файле мы создадим простую, но очень мощную функцию, которую для краткости назовем `t` (от "translate").

    ```python
    # в core/localization.py
    from kivymd.app import MDApp
    
    def t(key):
        app = MDApp.get_running_app()
        # Получаем текущий язык интерфейса из настроек
        lang = app.db_manager.get_setting('ui_language', 'ru') 
        # Находим перевод по ключу. Если не находим - возвращаем сам ключ
        return TRANSLATIONS.get(lang, {}).get(key, key)
    ```

---

#### **Шаг 21: Интеграция Переводчика в Приложение**

**Цель:** Научить `.kv` файлы и `.py` файлы использовать нашу новую функцию `t` вместо "зашитого" текста.

1.  **Доступ к `t` из KV-файлов:**
    *   Kivy позволяет делать функции доступными в `kv`. Мы добавим `t` в наш главный класс приложения в `main.py`:
    ```python
    # в main.py
    from core.localization import t
    
    class PhraseWeaverApp(MDApp):
        # Делаем функцию `t` доступной в KV как `app.t`
        t = t 
        # ...
    ```

2.  **Рефакторинг `.kv` файлов:**
    *   Это самая кропотливая, но важная часть. Мы пройдемся по **каждому** нашему `.kv` файлу и заменим все строки.

    **Было:**
    ```kv
    <TrainingScreen>:
        MDTopAppBar:
            title: "Тренировка"
        MDRaisedButton:
            text: "Проверить"
    ```

    **Стало:**
    ```kv
    <TrainingScreen>:
        MDTopAppBar:
            # Теперь title будет динамически меняться
            title: app.t('training') 
        MDRaisedButton:
            text: app.t('check_answer')
    ```
    Мы заменим **абсолютно весь** видимый пользователю текст на вызовы `app.t('key')`.

---

#### **Шаг 22: Добавляем выбор языка интерфейса в Настройки**

**Цель:** Дать пользователю возможность самому переключать язык приложения.

1.  **Расширяем `screens/settings_screen.kv`:**
    *   Мы добавим еще один `TwoLineAvatarIconListItem`, аналогичный выбору "языка перевода", но для "языка интерфейса".
    *   `id` у него будет, например, `ui_lang_item`.

2.  **Дописываем логику в `screens/settings_screen.py`:**
    *   Мы создадим новый метод `show_ui_language_dialog()`, который будет работать точно так же, как `show_target_language_dialog()`, но сохранять настройку в `db_manager.set_setting('ui_language', new_code)`.

3.  **"Магия" перезагрузки интерфейса:**
    *   **Проблема:** Просто изменить настройку в БД недостаточно. Приложение должно "перерисовать" себя с новыми переводами.
    *   **Решение:** После смены языка интерфейса мы будем показывать диалоговое окно с сообщением "Настройки языка будут применены после перезапуска приложения." и кнопкой "Перезапустить". По нажатию на "Перезапустить" мы можем реализовать элегантную перезагрузку приложения.

