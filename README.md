### Общий План разработки (Roadmap)

#  версия python 3.11.9 !!!!

Прежде чем мы напишем первую строчку кода, я хочу обозначить общую последовательность наших действий, чтобы у вас было полное понимание процесса:

Шаг 0: Подготовка рабочего окружения и структуры проекта. Создадим фундамент: папки, базовые файлы, настроим виртуальное окружение. (Наш текущий шаг)

Шаг 1: Создание слоя для работы с базой данных. Напишем код, который будет управлять таблицами SQLite, чтобы остальное приложение могло легко сохранять и получать данные.

    Резюме шага 1:

    Мы создали изолированный модуль для работы с базой данных (core/database.py).
    При первом запуске он автоматически создает всю необходимую структуру таблиц согласно ТЗ.
    Мы реализовали базовые функции для создания и получения списка колод.
    Приложение теперь корректно управляет жизненным циклом соединения с БД (открывает при старте, закрывает при выходе).
    Мы использовали лучшие практики: логирование, обработку ошибок, автоматическое управление транзакциями и row_factory для удобного получения данных.

Шаг 2: Разработка базового UI на Kivy/KivyMD. Создадим главный экран "Колоды" и настроим навигацию между экранами. Пока без логики.

    Резюме шага 2:
    
    Мы создали архитектуру для многоэкранного приложения с помощью ScreenManager.
    Мы вынесли дизайн и логику первого экрана (DeckListScreen) в отдельный файл, следуя лучшим практикам.
    Мы научились отделять структуру интерфейса (KV-язык) от логики на Python.
    Наше приложение теперь не просто запускается, а показывает реальные данные из базы данных, динамически строя по ним список.
    Мы заложили основу для навигации — при нажатии на колоду мы уже можем отследить это событие.


Шаг 3: Разработка модуля "Обогащения". Напишем ядро нашего приложения — код, который будет ходить в интернет за переводами, примерами и аудио. Мы сделаем его полностью независимым от интерфейса.

    Резюме шага 3:

    Перевод успешно получен.
    Аудио для фразы и перевода сгенерировано.
    Приложение столкнулось с Ratelimit от DuckDuckGo. Это нормальное поведение, и наш код правильно его обработал: он не упал, а вежливо сообщил об ошибке и вернул пустой список примеров. Это как раз та надежность, к которой мы стремились. В реальном использовании такие лимиты срабатывают редко.
    Программа завершилась корректно и собрала все данные, которые смогла получить.

Шаг 4: Интеграция. Экран создания карточки. Свяжем UI и модуль "Обогащения". Создадим экран, где пользователь сможет вводить фразу и запускать процесс обогащения контента.

    Резюме шага 4:

    1. Создали новый Экран "Создания Карточки":
        - Разработали UI (CreationScreen) с полями для ввода полного предложения и ключевой фразы.
        - Разместили на нем кнопки для запуска процесса ("Обогатить") и сохранения результата ("Сохранить в колоду").
    2. Реализовали главную "фишку" приложения — асинхронное обогащение:
        - Написали логику, которая по нажатию кнопки "Обогатить ✨" запускает наш enrichment.py в отдельном фоновом потоке.
        - Это гарантирует, что интерфейс приложения никогда не "зависает", даже если поиск перевода или примеров занимает много времени. Пользователь всегда может взаимодействовать с приложением.
    3. Создали интуитивно понятный пользовательский опыт (UX) для долгой операции:
        - При запуске обогащения кнопка становится неактивной, и появляется индикатор загрузки (спиннер). Пользователь визульно понимает, что идет работа.
        - После завершения процесса спиннер исчезает, и на экране появляются результаты (перевод и примеры) в виде интерактивных кнопок.
        - Кнопка "Сохранить" активируется только после успешного получения данных, что логично и предотвращает сохранение пустых карточек.
    4. Наладили навигацию:
        - Теперь с главного экрана (DeckListScreen) можно перейти на экран создания, нажав плавающую кнопку "+".
        - С экрана создания можно вернуться назад, используя системную кнопку "назад" или стрелку в левом верхнем углу.
    5. Провели масштабную отладку и адаптацию:
        - Мы столкнулись с реальными проблемами разработки: несовместимость версий библиотек (translators, httpx), различия в версиях Python.
        - Мы успешно обновили фреймворк KivyMD до последней версии и адаптировали весь наш UI-код к его новому API, исправив множество ошибок импорта и использования виджетов.
        - Мы отладили сложную логику управления состоянием UI (вечные спиннеры), сделав ее надежной.

Шаг 5: Реализация алгоритма SRS и экрана тренировки. Создадим логику интервальных повторений и интерфейс для прохождения карточек.

Шаг 6: Финальная полировка и сборка. Добавим обработку ошибок, "умную" вставку из буфера обмена и подготовим все для сборки в .apk файл.

Этот план гибок, но он дает нам четкое направление. Начнем с самого начала.